#ifndef WBC_ROS_WHOLE_BODY_CONTROLLER_HPP
#define WBC_ROS_WHOLE_BODY_CONTROLLER_HPP


#include <rclcpp/rclcpp.hpp>
#include <realtime_tools/realtime_buffer.hpp>
#include <realtime_tools/realtime_publisher.hpp>

#include <wbc_msgs/msg/rigid_body_state.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <trajectory_msgs/msg/joint_trajectory.hpp>
#include <std_msgs/msg/float64.hpp>
#include <std_msgs/msg/float64_multi_array.hpp>
#include <wbc_msgs/msg/task_status.hpp>
#include <wbc_msgs/msg/wbc_timing_stats.hpp>
#include <wbc_msgs/msg/task_weights.hpp>
#include <wbc_msgs/msg/task_activation.hpp>

#include <wbc/core/RobotModel.hpp>
#include <wbc/core/PluginLoader.hpp>
#include <wbc/core/Scene.hpp>
#include <wbc/core/QPSolver.hpp>
#include <wbc/tools/JointIntegrator.hpp>

#include "conversions.hpp"
#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <wbc_ros/task_interface.hpp>

// auto-generated by generate_parameter_library
#include "whole_body_controller_parameters.hpp"

namespace wbc_ros{

/**
@brief WBCNode - Main ROS interface for the WBC libary (https://github.com/ARC-OPT/wbc). This node implements a ros 2 controller,
which does the following in update call:

   1. Update the internal robot model with the current joint status (read from hardware interfaces)
   2. Update task references, task weights, joints weights and contacts
   3. Set up a quadratic program, which includes all tasks and constraints
   4. Solve the QP 
   5. Integrate and write the solution to the hardware interfaces

Subscribed Topics:
 - `<task_name>/task_weights` (`std_msgs/Float64MultiArray`): Task weights for task <task_name>. Can be used to set the priority of different aspects of one tasks, e.g.,
    certain directions in task space. Size must be 6 for Cartesian tasks, 3 for CoM tasks, 3 for contact force tasks. For joint space tasks, 
    the size must match the number of configured joints for this task.
 - `<task_name>/activation` (`std_msgs/Float64`): Activation value for task <task_name>. Can be used to activate/deactivate a task entirely.
 - `joint_weights` (`std_msgs/Float64MultiArray`): Joint weight vector. Can be used to prioritize or activate/deactivate certain joints.

 Published Topics (Debug only):
 - `solver_output` (`trajectory_msgs/JointTrajectory`): Solution of the QP. No. of points in the trajectory is always 1. Size of this point is same as number
    of non-fixed joints in URDF.
 - `timing_stats` (`wbc_msgs/WbcTimingStats`): Computation time for different processing steps in WBC.

 Parameters:
 - See whole_body_controller_parameters.yaml
*/
class WholeBodyController : public rclcpp_lifecycle::LifecycleNode{

   enum ControlMode{
      unset = -1,
      velocity = 0,
      acceleration = 1
   };   

   // Some shortcuts
   using CommandMsg = trajectory_msgs::msg::JointTrajectory;
   using CommandPublisher = rclcpp::Publisher<CommandMsg>;
   using RTCommandPublisher = realtime_tools::RealtimePublisher<CommandMsg>;

   using JointStateMsg = sensor_msgs::msg::JointState;
   using JointStateMsgPtr = std::shared_ptr<JointStateMsg>;
   using JointStateSubscription = rclcpp::Subscription<JointStateMsg>::SharedPtr;
   using RTJointStateBuffer = realtime_tools::RealtimeBuffer<JointStateMsgPtr>;

   using JointWeightMsg = std_msgs::msg::Float64MultiArray;
   using JointWeightMsgPtr = std::shared_ptr<JointWeightMsg>;
   using JointWeightSubscription = rclcpp::Subscription<JointWeightMsg>::SharedPtr;
   using RTJointWeightBuffer = realtime_tools::RealtimeBuffer<JointWeightMsgPtr>;    

   using TimingStatsMsg = wbc_msgs::msg::WbcTimingStats;
   using TimingStatsPublisher = rclcpp::Publisher<TimingStatsMsg>;
   using RTTimingStatsPublisher = realtime_tools::RealtimePublisher<TimingStatsMsg>;

protected:
   wbc::ScenePtr scene;
   wbc::RobotModelPtr robot_model;
   wbc::QPSolverPtr solver;

   wbc::types::JointState joint_state;
   wbc::types::RigidBodyState floating_base_state;
   wbc::HierarchicalQP qp;
   wbc::types::JointCommand solver_output;
   wbc::JointIntegrator joint_integrator;
   bool has_floating_base_state;
   int update_rate;
   bool has_joint_state;

   CommandMsg solver_output_msg;
   CommandPublisher::SharedPtr solver_output_publisher;
   std::unique_ptr<RTCommandPublisher> rt_solver_output_publisher;

   TimingStatsMsg timing_stats;
   TimingStatsPublisher::SharedPtr timing_stats_publisher;
   std::unique_ptr<RTTimingStatsPublisher> rt_timing_stats_publisher;

   JointWeightSubscription joint_weight_subscriber;
   RTJointWeightBuffer rt_joint_weight_buffer;
   JointWeightMsgPtr joint_weight_msg;

   JointStateSubscription joint_state_subscriber;
   RTJointStateBuffer rt_joint_state_buffer;
   JointStateMsgPtr joint_state_msg;

   rclcpp::Time stamp;
   rclcpp::TimerBase::SharedPtr timer;

   void update_tasks();
   void update();
   void update_contacts();
   void joint_weight_callback(const JointWeightMsgPtr msg);
   void joint_state_callback(const JointStateMsgPtr msg);   

   // Parameters from ROS
   std::shared_ptr<whole_body_controller::ParamListener> param_listener;
   whole_body_controller::Params params;

   std::vector<TaskInterfacePtr> task_interfaces;

public:
   WholeBodyController(const rclcpp::NodeOptions & options = rclcpp::NodeOptions());
   ~WholeBodyController(){}

   virtual CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
   virtual CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
   virtual CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
   virtual CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
   virtual CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
   virtual CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
};

}

#endif
