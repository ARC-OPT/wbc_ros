#ifndef WBC_ROS_WHOLE_BODY_CONTROLLER_HPP
#define WBC_ROS_WHOLE_BODY_CONTROLLER_HPP


#include <rclcpp/rclcpp.hpp>
#include <controller_interface/chainable_controller_interface.hpp>
#include <hardware_interface/types/hardware_interface_type_values.hpp>
#include <realtime_tools/realtime_buffer.h>
#include <realtime_tools/realtime_publisher.h>

#include <wbc_msgs/msg/rigid_body_state.hpp>
#include <sensor_msgs/msg/joint_state.hpp>
#include <trajectory_msgs/msg/joint_trajectory.hpp>
#include <std_msgs/msg/float64.hpp>
#include <std_msgs/msg/float64_multi_array.hpp>
#include <wbc_msgs/msg/task_status.hpp>
#include <wbc_msgs/msg/wbc_timing_stats.hpp>
#include <wbc_msgs/msg/task_weights.hpp>
#include <wbc_msgs/msg/task_activation.hpp>

//#include "controllers/controller_node.hpp"
#include <wbc/core/RobotModel.hpp>
#include <wbc/core/PluginLoader.hpp>
#include <wbc/core/Scene.hpp>
#include <wbc/core/QPSolver.hpp>
#include <wbc/tools/JointIntegrator.hpp>

#include <base/commands/Joints.hpp>

// auto-generated by generate_parameter_library
#include "whole_body_controller_parameters.hpp"

namespace wbc_ros{

/**
@brief WBCNode - Main ROS interface for the WBC libary (https://github.com/ARC-OPT/wbc). This node implements a peridic control loop,
which does the following in every control cycle:

   1. Update the internal robot with the current joint status
   2. Update the reference values for all tasks
   3. Set up a quadratic program, which includes all tasks and constraints
   4. Solve the QP and outputs the solver output
   5. Publish debug info about the task status and the QP

Subscribed Topics:
 - `joint_states` (`sensor_msgs/JointState`): The current joint state of the entire robot. Must contain all non-fixed joints from the URDF used in WBC. Must contain
    at least positions for Veloicty-based WBC and positions/velocities for acceleration-based WBC, e.g., TSID
 - `floating_base_state` (`wbc_msgs/RigidBodyState`): The state of the floating base. Only required if floating_base is set to true in the wbc configuration. Must contain
    at least pose for Veloicty-based WBC and pose/twist for acceleration-based WBC, e.g., TSID
 - `ref_mytask` (`wbc_msgs/RigidBodyState` or `sensor_msgs/JointState`): Reference for task mytask. For Cartesian space tasks this must be a twist or spatial acceleration,
    for joint space tasks, this must be joint velocities or accelerations.
 - `weights_mytask` (`std_msgs/Float64MultiArray`): Task weights for task mytask. Can be used to set the priority of different aspects of one tasks, e.g.,
    certain directions in task space. Size must be 6 for Cartesian space tasks. For joint space tasks, the size must match the number of configured joints for this task.
 - `activation_mytask` (`std_msgs/Float64`): Activation value for task mytask. Can be used to activate/deactivate a task entirely.
 - `joint_weights` (`std_msgs/Float64MultiArray`): Joint weight vector. Can be used to prioritize or activate/deactivate certain joints.

 Published Topics:
 - `status_mytask` (`wbc_msgs/RigidBodyState` or `sensor_msgs/JointState`): Status for task mytask For Cartesian space tasks: Current pose, twist and
   spatial acceleration for the kinematic chain associated with this task. For joint space tasks: position, velocity and acceleration of the joints associated with this task.
 - `task_mytask` (`wbc_msgs/TaskStatus`): Debug info on task mytask.
 - `solver_output` (`trajectory_msgs/JointTrajectory`): Solution of the QP. No. of points in the trajectory is always 1. Size of this point is same as number
    of non-fixed joints in URDF.
 - `timing_stats` (`wbc_msgs/WbcTimingStats`): Computation time for different processing steps in WBC.

 Parameters:
 - `control_rate` (double): Loop rate of the WBC in Hz
 - `integrate` (bool): If true, the solver output will be integrated once for velocity-based WBC and twice for acceleration-based WBC
 - `robot_model_config` (dict): Configuration of the robot model like, e.g., URDF filename, type of model, floating base etc.
    (see <a href="https://github.com/ARC-OPT/wbc/blob/master/src/core/RobotModelConfig.hpp">here</a>) for more information.
 - `qp_solver` (string): Name of the QP solver to use, can be one of qpoases, qpswift, eiquadprog, proxqp
 - `wbc_config` (dict): Tasks configuration. This contains information about each task, which is stacked inside the QP. See
   (see <a href="https://github.com/ARC-OPT/wbc/blob/master/src/core/TaskConfig.hpp">here</a>) for more information.
*/
class WholeBodyController : public controller_interface::ChainableControllerInterface{
    const std::vector<std::string> cart_vel_interfaces = {"twist/linear/x","twist/linear/y","twist/linear/z",
                                                          "twist/angular/x","twist/angular/y","twist/angular/z"};
    const std::vector<std::string> cart_acc_interfaces = {"acc/linear/x","acc/linear/y","acc/linear/z",
                                                          "acc/angular/x","acc/angular/y","acc/angular/z"};
    // Some shortcuts
    using CommandMsg = trajectory_msgs::msg::JointTrajectory;
    using CommandPublisher = rclcpp::Publisher<CommandMsg>;
    using RTCommandPublisher = realtime_tools::RealtimePublisher<CommandMsg>;

    using RbsMsg = wbc_msgs::msg::RigidBodyState;
    using RbsPublisher = rclcpp::Publisher<RbsMsg>;
    using RTRbsPublisher = realtime_tools::RealtimePublisher<RbsMsg>;

    using JointsMsg = sensor_msgs::msg::JointState;
    using JointsPublisher = rclcpp::Publisher<JointsMsg>;
    using RTJointsPublisher = realtime_tools::RealtimePublisher<JointsMsg>;

    using TaskWeightMsg = wbc_msgs::msg::TaskWeights;
    using TaskWeightMsgPtr = std::shared_ptr<TaskWeightMsg>;
    using TaskWeightSubscription = rclcpp::Subscription<TaskWeightMsg>::SharedPtr;
    using RTTaskWeightBuffer = realtime_tools::RealtimeBuffer<TaskWeightMsgPtr>;

    using TaskActivationMsg = wbc_msgs::msg::TaskActivation;
    using TaskActivationMsgPtr = std::shared_ptr<TaskActivationMsg>;
    using TaskActivationSubscription = rclcpp::Subscription<TaskActivationMsg>::SharedPtr;
    using RTTaskActivationBuffer = realtime_tools::RealtimeBuffer<TaskActivationMsgPtr>;

    using TimingStatsMsg = wbc_msgs::msg::WbcTimingStats;
    using TimingStatsPublisher = rclcpp::Publisher<TimingStatsMsg>;
    using RTTimingStatsPublisher = realtime_tools::RealtimePublisher<TimingStatsMsg>;

    const std::vector<std::string> allowed_interface_types = {
        hardware_interface::HW_IF_POSITION,
        hardware_interface::HW_IF_VELOCITY,
        hardware_interface::HW_IF_ACCELERATION,
        hardware_interface::HW_IF_EFFORT,
    };

protected:

   wbc::ScenePtr scene;
   wbc::RobotModelPtr robot_model;
   wbc::QPSolverPtr solver;

   base::samples::Joints joint_state;
   base::samples::RigidBodyStateSE3 reference_cart;
   base::samples::RigidBodyStateSE3 floating_base_state;
   base::commands::Joints reference_jnt;
   wbc::JointWeights joint_weights;
   uint no_of_joints;
   wbc::HierarchicalQP qp;
   base::commands::Joints solver_output;
   wbc::JointIntegrator joint_integrator;
   std::vector<wbc::TaskConfig> task_config;
   bool has_floating_base_state;
   int update_rate;

   std::map<std::string, std::vector<int>> command_indices;
   std::map<std::string, std::vector<int>> state_indices;

   CommandMsg solver_output_msg;
   CommandPublisher::SharedPtr solver_output_publisher;
   std::unique_ptr<RTCommandPublisher> rt_solver_output_publisher;

   TimingStatsMsg timing_stats;
   TimingStatsPublisher::SharedPtr timing_stats_publisher;
   std::unique_ptr<RTTimingStatsPublisher> rt_timing_stats_publisher;

   RbsMsg task_status_cart;
   std::vector<RbsPublisher::SharedPtr> task_status_publishers_cart;
   std::vector<std::unique_ptr<RTRbsPublisher>> rt_task_status_publishers_cart;

   JointsMsg task_status_jnt;
   std::vector<JointsPublisher::SharedPtr> task_status_publishers_jnt;
   std::vector<std::unique_ptr<RTJointsPublisher>> rt_task_status_publishers_jnt;

   TaskWeightSubscription task_weight_subscriber;
   RTTaskWeightBuffer rt_task_weight_buffer;
   TaskWeightMsgPtr task_weight_msg;

   TaskActivationSubscription task_activation_subscriber;
   RTTaskActivationBuffer rt_task_activation_buffer;
   TaskActivationMsgPtr task_activation_msg;

   rclcpp::Time stamp;

   void read_state_from_hardware();
   void write_command_to_hardware();
   void update_tasks();
   void publish_task_status();

   bool has_state_interface(const std::string & interface_name){
       return !state_indices[interface_name].empty();
   }
   bool has_command_interface(const std::string & interface_name){
       return !command_indices[interface_name].empty();
   }
   int get_state_idx(const std::string &joint_name, const std::string & interface_name){
       for(uint i = 0; i < state_interfaces_.size(); i++){
           const hardware_interface::LoanedStateInterface &s = state_interfaces_[i];
           if(s.get_interface_name() == interface_name && s.get_name().find(params.prefix + joint_name) != std::string::npos)
               return i;
       }
       return -1;
   }
   int get_command_idx(const std::string &joint_name, const std::string & interface_name){
       for(uint i = 0; i < command_interfaces_.size(); i++){
           const hardware_interface::LoanedCommandInterface &s = command_interfaces_[i];
           if(s.get_interface_name() == interface_name && s.get_name().find(params.prefix + joint_name) != std::string::npos)
               return i;
       }
       return -1;
   }
   // Parameters from ROS
   std::shared_ptr<whole_body_controller::ParamListener> param_listener;
   whole_body_controller::Params params;

   void task_weight_callback(const TaskWeightMsgPtr msg);
   void task_activation_callback(const TaskActivationMsgPtr msg);

public:
   WholeBodyController();
   ~WholeBodyController(){}

   virtual controller_interface::InterfaceConfiguration command_interface_configuration() const override;
   virtual controller_interface::InterfaceConfiguration state_interface_configuration() const override;
   virtual controller_interface::return_type update_and_write_commands(const rclcpp::Time & time, const rclcpp::Duration & period) override;
   virtual controller_interface::CallbackReturn on_init() override;
   virtual controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
   virtual controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
   virtual controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
   virtual controller_interface::CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
   virtual controller_interface::CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
   virtual controller_interface::CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;

protected:
    virtual std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces();
    virtual controller_interface::return_type update_reference_from_subscribers();
};

}

#endif
