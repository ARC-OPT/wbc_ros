#ifndef WBC_ROS_COM_POSITION_CONTROLLER_HPP
#define WBC_ROS_COM_POSITION_CONTROLLER_HPP

#include <wbc_msgs/msg/rigid_body_state.hpp>

#include <controller_interface/chainable_controller_interface.hpp>
#include <wbc/controllers/CartesianPosPDController.hpp>
#include <wbc/types/RigidBodyState.hpp>
#include <realtime_tools/realtime_buffer.hpp>
#include <realtime_tools/realtime_publisher.hpp>

// auto-generated by generate_parameter_library
#include "com_position_controller_parameters.hpp"

namespace wbc_ros{

/**
@brief Position controller in Cartesian space. See <a href="https://github.com/ARC-OPT/wbc/blob/master/src/controllers/CartesianPosPDController.hpp">here</a> for details.
*/
class CoMPositionController : public controller_interface::ChainableControllerInterface{
    using RbsMsg = wbc_msgs::msg::RigidBodyState;
    using RbsMsgPtr = std::shared_ptr<wbc_msgs::msg::RigidBodyState>;
    using RbsSubscription = rclcpp::Subscription<RbsMsg>::SharedPtr;
    using RTRbsBuffer = realtime_tools::RealtimeBuffer<RbsMsgPtr>;
    using RbsPublisher = rclcpp::Publisher<RbsMsg>;
    using RTRbsPublisher = realtime_tools::RealtimePublisher<RbsMsg>;

    const std::vector<std::string> pos_interfaces = {"pose/position/x","pose/position/y","pose/position/z"};
    const std::vector<std::string> vel_interfaces = {"twist/linear/x","twist/linear/y","twist/linear/z"};
    const std::vector<std::string> acc_interfaces = {"acceleration/linear/x","acceleration/linear/y","acceleration/linear/z"};

protected:
    wbc::CartesianPosPDController* controller;
    wbc::types::RigidBodyState feedback;
    wbc::types::RigidBodyState setpoint;
    wbc::types::RigidBodyState control_output;
    Eigen::VectorXd state_interface_values;
    Eigen::VectorXd reference_interface_values;

    std::shared_ptr<RbsMsg> setpoint_msg;
    RTRbsBuffer rt_setpoint_buffer;
    RbsSubscription setpoint_subscriber;

    RbsMsg control_output_msg;
    RbsPublisher::SharedPtr control_output_publisher;
    std::unique_ptr<RTRbsPublisher> rt_control_output_publisher;

    std::shared_ptr<com_position_controller::ParamListener> param_listener;
    com_position_controller::Params params;

    virtual std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces() override;
    virtual controller_interface::return_type update_reference_from_subscribers(const rclcpp::Time & time, const rclcpp::Duration & period) override;

    void setpoint_callback(const RbsMsgPtr msg);
    void write_control_output();
    bool read_feedback();
    bool read_setpoint();

public:
    CoMPositionController();
    ~CoMPositionController(){}

    virtual controller_interface::InterfaceConfiguration command_interface_configuration() const override;
    virtual controller_interface::InterfaceConfiguration state_interface_configuration() const override;
    virtual controller_interface::return_type update_and_write_commands(const rclcpp::Time & time, const rclcpp::Duration & period);
    virtual controller_interface::CallbackReturn on_init() override;
    virtual controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
};

}

#endif
