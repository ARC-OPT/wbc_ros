#ifndef JOINT_POSITION_CONTROLLER_NODE_HPP
#define JOINT_POSITION_CONTROLLER_NODE_HPP

#include <sensor_msgs/msg/joint_state.hpp>
#include <trajectory_msgs/msg/joint_trajectory.hpp>

#include <controller_interface/chainable_controller_interface.hpp>
#include <wbc/controllers/JointPosPDController.hpp>
#include <wbc/types/JointCommand.hpp>
#include <wbc/types/JointState.hpp>

#include <realtime_tools/realtime_buffer.hpp>
#include <realtime_tools/realtime_publisher.hpp>
#include <hardware_interface/types/hardware_interface_type_values.hpp>

// auto-generated by generate_parameter_library
#include "joint_position_controller_parameters.hpp"

namespace wbc_ros{

/**
@brief Position controller in joint space. See <a href="https://github.com/ARC-OPT/wbc/blob/master/src/controllers/JointPosPDController.hpp">here</a> for details.
*/
class JointPositionController : public controller_interface::ChainableControllerInterface{
    using JointCommandMsg = trajectory_msgs::msg::JointTrajectory;
    using JointCommandMsgPtr = std::shared_ptr<JointCommandMsg>;
    using JointCommandSubscription = rclcpp::Subscription<JointCommandMsg>::SharedPtr;
    using RTJointCommandBuffer = realtime_tools::RealtimeBuffer<JointCommandMsgPtr>;

    using JointCommandPublisher = rclcpp::Publisher<JointCommandMsg>;
    using RTJointCommandPublisher = realtime_tools::RealtimePublisher<JointCommandMsg>;

    const std::vector<std::string> reference_interface_names = {"position","velocity","acceleration"};
    const std::vector<std::string> allowed_state_interface_types = {
        hardware_interface::HW_IF_POSITION,
        hardware_interface::HW_IF_VELOCITY
    };

protected:
    JointCommandMsgPtr setpoint_msg;
    RTJointCommandBuffer rt_setpoint_buffer;
    JointCommandSubscription setpoint_subscriber;

    JointCommandMsg control_output_msg;
    JointCommandPublisher::SharedPtr control_output_publisher;
    std::unique_ptr<RTJointCommandPublisher> rt_control_output_publisher;

    wbc::JointPosPDController* controller;
    wbc::types::JointCommand setpoint;
    wbc::types::JointState feedback;
    wbc::types::JointCommand control_output;

    std::map<std::string, std::vector<int>> state_indices;
    bool has_setpoint;

    std::shared_ptr<joint_position_controller::ParamListener> param_listener;
    joint_position_controller::Params params;
    Eigen::VectorXd reference_interface_values;

    void setpoint_callback(const JointCommandMsgPtr msg);
    void read_state_from_hardware_interfaces();
    void write_control_output_to_hardware();
    bool has_state_interface(const std::string & interface_name){
        return !state_indices[interface_name].empty();
    }
    int get_state_idx(const std::string &joint_name, const std::string & interface_name){
        for(uint i = 0; i < state_interfaces_.size(); i++){
            const hardware_interface::LoanedStateInterface &s = state_interfaces_[i];
            if(s.get_interface_name() == interface_name && s.get_name().find(joint_name) != std::string::npos)
                return i;
        }
        return -1;
    }

    virtual std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces();
    virtual controller_interface::return_type update_reference_from_subscribers(const rclcpp::Time & time, const rclcpp::Duration & period);
public:
    JointPositionController();
    ~JointPositionController(){}

    virtual controller_interface::InterfaceConfiguration command_interface_configuration() const override;
    virtual controller_interface::InterfaceConfiguration state_interface_configuration() const override;
    virtual controller_interface::return_type update_and_write_commands(const rclcpp::Time & time, const rclcpp::Duration & period);
    virtual controller_interface::CallbackReturn on_init() override;
    virtual controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
};

}

#endif
