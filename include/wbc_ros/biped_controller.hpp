#ifndef WBC_ROS_BIPED_CONTROLLER_HPP
#define WBC_ROS_BIPED_CONTROLLER_HPP

#include <rclcpp_lifecycle/lifecycle_node.hpp>
#include <wbc_ros/conversions.hpp>
#include <realtime_tools/realtime_buffer.hpp>
#include <realtime_tools/realtime_publisher.hpp>
#include <wbc_msgs/msg/wbc_timing_stats.hpp>
#include <std_msgs/msg/float64_multi_array.hpp>
#include <std_msgs/msg/float64.hpp>

#include <wbc/core/RobotModel.hpp>
#include <wbc/core/Scene.hpp>
#include <wbc/core/QPSolver.hpp>
#include <wbc/tools/JointIntegrator.hpp>
#include <wbc/core/QuadraticProgram.hpp>
#include <wbc/controllers/CartesianPosPDController.hpp>
#include <wbc/controllers/JointPosPDController.hpp>
#include <wbc/tasks/CoMAccelerationTask.hpp>
#include <wbc/tasks/SpatialAccelerationTask.hpp>
#include <wbc/tasks/JointAccelerationTask.hpp>
#include <wbc/tasks/ContactForceTask.hpp>

// auto-generated by generate_parameter_library
#include "biped_controller_parameters.hpp"

namespace wbc_ros{

    class BipedController : public rclcpp_lifecycle::LifecycleNode{

        using JointCommandMsg = robot_control_msgs::msg::JointCommand;
        using JointCommandMsgPtr = robot_control_msgs::msg::JointCommand::SharedPtr;
        using JointCommandPublisher = rclcpp::Publisher<JointCommandMsg>;
        using RTJointCommandPublisher = realtime_tools::RealtimePublisher<JointCommandMsg>;
        using JointCommandSubscription = rclcpp::Subscription<JointCommandMsg>::SharedPtr;
        using RTJointCommandBuffer = realtime_tools::RealtimeBuffer<JointCommandMsgPtr>;

        using RobotStateMsg = robot_control_msgs::msg::RobotState;
        using RobotStateMsgPtr = std::shared_ptr<RobotStateMsg>;
        using RobotStateSubscription = rclcpp::Subscription<RobotStateMsg>::SharedPtr;
        using RTRobotStateBuffer = realtime_tools::RealtimeBuffer<RobotStateMsgPtr>;

        using DoubleArrayMsg = std_msgs::msg::Float64MultiArray;
        using DoubleArrayMsgPtr = std::shared_ptr<DoubleArrayMsg>;
        using DoubleArraySubscription = rclcpp::Subscription<DoubleArrayMsg>::SharedPtr;
        using RTDoubleArrayBuffer = realtime_tools::RealtimeBuffer<DoubleArrayMsgPtr>;    

        using TimingStatsMsg = wbc_msgs::msg::WbcTimingStats;
        using TimingStatsPublisher = rclcpp::Publisher<TimingStatsMsg>;
        using RTTimingStatsPublisher = realtime_tools::RealtimePublisher<TimingStatsMsg>;

        using DoubleMsg = std_msgs::msg::Float64;
        using DoubleMsgPtr = std::shared_ptr<DoubleMsg>;
        using DoubleSubscription = rclcpp::Subscription<DoubleMsg>::SharedPtr;
        using RTDoubleBuffer = realtime_tools::RealtimeBuffer<DoubleMsgPtr>;

        using RigidBodyStateMsg = robot_control_msgs::msg::RigidBodyState;
        using RigidBodyStateMsgPtr = std::shared_ptr<RigidBodyStateMsg>;
        using RigidBodyStateSubscription = rclcpp::Subscription<RigidBodyStateMsg>::SharedPtr;
        using RTRigidBodyStateBuffer = realtime_tools::RealtimeBuffer<RigidBodyStateMsgPtr>;     

        using WrenchMsg = geometry_msgs::msg::Wrench;
        using WrenchMsgPtr = std::shared_ptr<WrenchMsg>;
        using WrenchSubscription = rclcpp::Subscription<WrenchMsg>::SharedPtr;
        using RTWrenchBuffer = realtime_tools::RealtimeBuffer<WrenchMsgPtr>;       

        using ContactsMsg = robot_control_msgs::msg::Contacts;
        using ContactsMsgPtr = robot_control_msgs::msg::Contacts::SharedPtr;
        using ContactsSubscription = rclcpp::Subscription<ContactsMsg>::SharedPtr;
        using RTContactsBuffer = realtime_tools::RealtimeBuffer<ContactsMsgPtr>;       

        class TaskInterface{
            DoubleArraySubscription task_weight_subscriber;
            RTDoubleArrayBuffer rt_task_weight_buffer;
            DoubleArrayMsgPtr task_weight_msg;

            DoubleSubscription task_activation_subscriber;
            RTDoubleBuffer rt_task_activation_buffer;
            DoubleMsgPtr task_activation_msg;

            public:
                TaskInterface(std::string task_name, std::shared_ptr<rclcpp_lifecycle::LifecycleNode> node) : 
                    has_task_weights(false),
                    has_task_activation(false),
                    task_name(task_name){  
                    task_weight_subscriber = node->create_subscription<DoubleArrayMsg>("~/" + task_name + "/task_weights", 
                                                                                      rclcpp::SystemDefaultsQoS(), 
                                                                                      bind(&TaskInterface::task_weight_callback, this, std::placeholders::_1));
                    task_activation_subscriber = node->create_subscription<DoubleMsg>("~/" + task_name + "/activation", 
                                                                                      rclcpp::SystemDefaultsQoS(), 
                                                                                      bind(&TaskInterface::task_activation_callback, this, std::placeholders::_1));
                }
                void task_weight_callback(const DoubleArrayMsgPtr msg){
                    rt_task_weight_buffer.writeFromNonRT(msg);
                    has_task_weights = true;
                }
                void task_activation_callback(const DoubleMsgPtr msg){
                    rt_task_activation_buffer.writeFromNonRT(msg);
                    has_task_activation = true;
                }
                void updateTaskWeights(wbc::TaskPtr task){
                    if(has_task_weights){
                        task_weight_msg = *rt_task_weight_buffer.readFromRT();
                        if(task_weight_msg.get()){
                            task->setWeights(Eigen::Map<Eigen::VectorXd>(task_weight_msg->data.data(), task_weight_msg->data.size()));
                        }
                    }
                    if(has_task_activation){
                        task_activation_msg = *rt_task_activation_buffer.readFromRT();
                        if (task_activation_msg.get())
                            task->setActivation(task_activation_msg->data);
                    }
                }

                virtual void update(wbc::RobotModelPtr robot_model) = 0;
                virtual void reset() = 0;
                bool has_task_weights;
                bool has_task_activation;
             std::string task_name;
        };
        using TaskInterfacePtr = std::shared_ptr<TaskInterface>;   

        class CoMTaskInterface : public TaskInterface{
            RigidBodyStateSubscription setpoint_subscriber;
            RTRigidBodyStateBuffer rt_setpoint_buffer;
            RigidBodyStateMsgPtr setpoint_msg;            
            public:
                CoMTaskInterface(std::string task_name, std::shared_ptr<rclcpp_lifecycle::LifecycleNode> node) : 
                    TaskInterface(task_name, node),
                    has_setpoint(false){
                    setpoint_subscriber = node->create_subscription<RigidBodyStateMsg>("~/" + task_name + "/setpoint", rclcpp::SystemDefaultsQoS(), 
                        bind(&CoMTaskInterface::setpoint_callback, this, std::placeholders::_1));                                                                           
                }
                void setpoint_callback(const RigidBodyStateMsgPtr msg){
                    rt_setpoint_buffer.writeFromNonRT(msg);
                    has_setpoint = true;
                }
                virtual void update(wbc::RobotModelPtr robot_model){
                    updateTaskWeights(task);
                    if(!has_setpoint)
                        return;
                    setpoint_msg = *rt_setpoint_buffer.readFromRT();
                    if(setpoint_msg.get()){
                        fromROS(*setpoint_msg, setpoint);
                        Eigen::Vector3d ctrl_out = controller.update(setpoint.pose, 
                                                             setpoint.twist, 
                                                             setpoint.acceleration, 
                                                             robot_model->centerOfMass().pose, 
                                                             robot_model->centerOfMass().twist).linear;
                        task->setReference(ctrl_out);
                    }
                }
                virtual void reset(){
                    task->reset();
                }
                bool has_setpoint;
                wbc::types::RigidBodyState setpoint;
                wbc::CartesianPosPDController controller;
                wbc::CoMAccelerationTaskPtr task;
        };
        using CoMTaskInterfacePtr = std::shared_ptr<CoMTaskInterface>;   

        class FootTaskInterface : public TaskInterface{
            RigidBodyStateSubscription setpoint_subscriber;
            RTRigidBodyStateBuffer rt_setpoint_buffer;
            RigidBodyStateMsgPtr setpoint_msg;
            public:
                FootTaskInterface(std::string task_name, std::shared_ptr<rclcpp_lifecycle::LifecycleNode> node) : 
                    TaskInterface(task_name, node),
                    has_setpoint(false){
                    setpoint_subscriber = node->create_subscription<RigidBodyStateMsg>("~/" + task_name + "/setpoint", rclcpp::SystemDefaultsQoS(), 
                        bind(&FootTaskInterface::setpoint_callback, this, std::placeholders::_1));   

                }       
                void setpoint_callback(const RigidBodyStateMsgPtr msg){
                    rt_setpoint_buffer.writeFromNonRT(msg);
                    has_setpoint = true;
                }
                virtual void update(wbc::RobotModelPtr robot_model){
                    updateTaskWeights(task);
                    if(!has_setpoint)
                        return;
                    setpoint_msg = *rt_setpoint_buffer.readFromRT();
                    if(setpoint_msg.get()){
                        fromROS(*setpoint_msg, setpoint);
                        wbc::types::SpatialAcceleration ctrl_out = controller.update(setpoint.pose, 
                                                             setpoint.twist, 
                                                             setpoint.acceleration,
                                                             robot_model->pose(task->tipFrame()),
                                                             robot_model->twist(task->tipFrame()));
                        task->setReference(ctrl_out);
                    }
                }
                virtual void reset(){
                    task->reset();
                }
                bool has_setpoint;
                wbc::types::RigidBodyState setpoint;
                wbc::CartesianPosPDController controller;
                wbc::SpatialAccelerationTaskPtr task;
        };
        using FootTaskInterfacePtr = std::shared_ptr<FootTaskInterface>;   

        class ContactForceTaskInterface : public TaskInterface{  
            WrenchSubscription setpoint_subscriber;
            RTWrenchBuffer rt_setpoint_buffer;
            WrenchMsgPtr setpoint_msg;
            public:
                ContactForceTaskInterface(std::string task_name, std::shared_ptr<rclcpp_lifecycle::LifecycleNode> node) : 
                    TaskInterface(task_name, node),
                    has_setpoint(false){
                    setpoint_subscriber = node->create_subscription<WrenchMsg>("~/" + task_name + "/setpoint", rclcpp::SystemDefaultsQoS(), 
                        bind(&ContactForceTaskInterface::setpoint_callback, this, std::placeholders::_1));  
                }     
                void setpoint_callback(const WrenchMsgPtr msg){
                    rt_setpoint_buffer.writeFromNonRT(msg);
                    has_setpoint = true;
                }
                virtual void update(wbc::RobotModelPtr /*robot_model*/){
                    updateTaskWeights(task);
                    if(!has_setpoint)
                        return;
                    setpoint_msg = *rt_setpoint_buffer.readFromRT();
                    if(setpoint_msg.get()){
                        fromROS(*setpoint_msg, setpoint);
                        task->setReference(setpoint);
                    }
                }
                virtual void reset(){
                    task->reset();
                }
                bool has_setpoint;
                wbc::types::Wrench setpoint;
                wbc::ContactForceTaskPtr task;

        };
        using ContactForceTaskInterfacePtr = std::shared_ptr<ContactForceTaskInterface>;  

        class JointPositionTaskInterface : public TaskInterface{
            JointCommandSubscription setpoint_subscriber;
            RTJointCommandBuffer rt_setpoint_buffer;
            JointCommandMsgPtr setpoint_msg;
            public:
                JointPositionTaskInterface(std::string task_name, std::shared_ptr<rclcpp_lifecycle::LifecycleNode> node) : 
                    TaskInterface(task_name, node),
                    has_setpoint(false){
                    setpoint_subscriber = node->create_subscription<JointCommandMsg>("~/" + task_name + "/setpoint", rclcpp::SystemDefaultsQoS(), 
                        bind(&JointPositionTaskInterface::setpoint_callback, this, std::placeholders::_1));   

                }       
                void setpoint_callback(const JointCommandMsgPtr msg){
                    rt_setpoint_buffer.writeFromNonRT(msg);
                    has_setpoint = true;
                }
                virtual void update(wbc::RobotModelPtr robot_model){
                    if(joint_idx_map.empty()){
                        for(auto n : task->jointNames())
                            joint_idx_map.push_back(robot_model->jointIndex(n));
                    }
                    updateTaskWeights(task);
                    if(!has_setpoint)
                        return;
                    setpoint_msg = *rt_setpoint_buffer.readFromRT();
                    if(setpoint_msg.get()){
                        fromROS(*setpoint_msg, joint_idx_map, setpoint);
                        std::cout<<setpoint.position.transpose()<<std::endl;
                        std::cout<<setpoint.velocity.transpose()<<std::endl;
                        std::cout<<setpoint.acceleration.transpose()<<std::endl;
                        std::cout<<robot_model->jointState().position.transpose()<<std::endl;
                        std::cout<<robot_model->jointState().velocity.transpose()<<std::endl;
                        Eigen::VectorXd ctrl_out = controller->update(setpoint.position, 
                                                                      setpoint.velocity, 
                                                                      setpoint.acceleration,
                                                                      robot_model->jointState().position,
                                                                      robot_model->jointState().velocity);
                        std::cout<<ctrl_out.transpose()<<std::endl<<std::endl;
                        task->setReference(ctrl_out);
                    }
                }
                virtual void reset(){
                    task->reset();
                }
                bool has_setpoint;
                wbc::types::JointCommand setpoint;
                wbc::JointPosPDControllerPtr controller;
                wbc::JointAccelerationTaskPtr task;
                std::vector<int> joint_idx_map;
        };
        using JointPositionTaskInterfacePtr = std::shared_ptr<JointPositionTaskInterface>;  

        public:
            BipedController(const rclcpp::NodeOptions & options);
            ~BipedController(){};

            virtual CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
            virtual CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
            virtual CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
            virtual CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
            virtual CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
            virtual CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
    
            void updateController();
            void joint_weight_callback(const DoubleArrayMsgPtr msg);
            void robot_state_callback(const RobotStateMsgPtr msg);
            void contacts_callback(const ContactsMsgPtr msg);

        protected:
            std::vector<TaskInterfacePtr> task_interfaces;

            wbc::ScenePtr scene;
            wbc::RobotModelPtr robot_model;
            wbc::QPSolverPtr solver;
            wbc::types::JointState joint_state;
            wbc::types::RigidBodyState floating_base_state;
            std::vector<wbc::types::Contact> contacts;
            bool has_robot_state;
            int update_rate;
            wbc::types::JointCommand solver_output;
            wbc::HierarchicalQP qp;
            wbc::JointIntegrator joint_integrator;

            JointCommandMsg solver_output_msg;
            JointCommandPublisher::SharedPtr solver_output_publisher;
            std::unique_ptr<RTJointCommandPublisher> rt_solver_output_publisher;

            TimingStatsMsg timing_stats;
            TimingStatsPublisher::SharedPtr timing_stats_publisher;
            std::unique_ptr<RTTimingStatsPublisher> rt_timing_stats_publisher;

            DoubleArraySubscription joint_weight_subscriber;
            RTDoubleArrayBuffer rt_joint_weight_buffer;
            DoubleArrayMsgPtr joint_weight_msg;

            RobotStateSubscription robot_state_subscriber;
            RTRobotStateBuffer rt_robot_state_buffer;
            RobotStateMsgPtr robot_state_msg;

            ContactsSubscription contacts_subscriber;
            RTContactsBuffer rt_contacts_buffer;
            ContactsMsgPtr contacts_msg;

            rclcpp::Time stamp;
            rclcpp::TimerBase::SharedPtr timer;

            std::shared_ptr<biped_controller::ParamListener> param_listener;
            biped_controller::Params params;

            std::vector<int> joint_idx_map;

    };



}

#endif