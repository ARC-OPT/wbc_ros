#ifndef WBC_ROS_CARTESIAN_POSITION_CONTROLLER_HPP
#define WBC_ROS_CARTESIAN_POSITION_CONTROLLER_HPP

#include <wbc_msgs/msg/rigid_body_state.hpp>

#include <controller_interface/chainable_controller_interface.hpp>
#include <wbc/controllers/CartesianPosPDController.hpp>
#include <base/samples/RigidBodyStateSE3.hpp>
#include <realtime_tools/realtime_buffer.h>
#include <realtime_tools/realtime_publisher.h>

// auto-generated by generate_parameter_library
#include "cartesian_position_controller_parameters.hpp"

namespace wbc_ros{

/**
@brief Position controller in Cartesian space. See <a href="https://github.com/ARC-OPT/wbc/blob/master/src/controllers/CartesianPosPDController.hpp">here</a> for details.
*/
class CartesianPositionController : public controller_interface::ChainableControllerInterface{
    using RbsMsg = wbc_msgs::msg::RigidBodyState;
    using RbsMsgPtr = std::shared_ptr<wbc_msgs::msg::RigidBodyState>;
    using RbsSubscription = rclcpp::Subscription<RbsMsg>::SharedPtr;
    using RTRbsBuffer = realtime_tools::RealtimeBuffer<RbsMsgPtr>;
    using RbsPublisher = rclcpp::Publisher<RbsMsg>;
    using RTRbsPublisher = realtime_tools::RealtimePublisher<RbsMsg>;

    const std::vector<std::string> reference_interface_names = {"pose/position/x","pose/position/y","pose/position/z",
                                                                "pose/orientation/x","pose/orientation/y","pose/orientation/z","pose/orientation/w",
                                                                "twist/linear/x","twist/linear/y","twist/linear/z",
                                                                "twist/angular/x","twist/angular/y","twist/angular/z",
                                                                "acc/linear/x","acc/linear/y","acc/linear/z",
                                                                "acc/angular/x","acc/angular/y","acc/angular/z"};
    const std::vector<std::string> command_interfaces_vel = {"twist/linear/x","twist/linear/y","twist/linear/z",
                                                             "twist/angular/x","twist/angular/y","twist/angular/z"};
    const std::vector<std::string> command_interfaces_acc = {"acc/linear/x","acc/linear/y","acc/linear/z",
                                                             "acc/angular/x","acc/angular/y","acc/angular/z"};


protected:
    ctrl_lib::CartesianPosPDController* controller;
    base::samples::RigidBodyStateSE3 feedback;
    base::samples::RigidBodyStateSE3 setpoint;
    base::samples::RigidBodyStateSE3 control_output;
    bool has_setpoint, has_feedback;

    std::shared_ptr<RbsMsg> setpoint_msg;
    RTRbsBuffer rt_setpoint_buffer;
    RbsSubscription setpoint_subscriber;

    std::shared_ptr<RbsMsg> feedback_msg;
    RTRbsBuffer rt_feedback_buffer;
    RbsSubscription feedback_subscriber;

    RbsMsg control_output_msg;
    RbsPublisher::SharedPtr control_output_publisher;
    std::unique_ptr<RTRbsPublisher> rt_control_output_publisher;

    std::shared_ptr<cartesian_position_controller::ParamListener> param_listener;
    cartesian_position_controller::Params params;

    virtual std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces();
    virtual controller_interface::return_type update_reference_from_subscribers();

    void setpoint_callback(const RbsMsgPtr msg);
    void feedback_callback(const RbsMsgPtr msg);
    void write_control_output_to_hardware();

public:
    CartesianPositionController();
    ~CartesianPositionController(){}

    virtual controller_interface::InterfaceConfiguration command_interface_configuration() const override;
    virtual controller_interface::InterfaceConfiguration state_interface_configuration() const override;
    virtual controller_interface::return_type update_and_write_commands(const rclcpp::Time & time, const rclcpp::Duration & period);
    virtual controller_interface::CallbackReturn on_init() override;
    virtual controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
    virtual controller_interface::CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
};

}

#endif
